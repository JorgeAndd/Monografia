

\chapter{Estudo de Caso e Metodologia}

Neste capítulo são apresentados os estudos de caso, onde os dados públicos do programa Bolsa Família são inseridos e extraídos de um banco de dados Cassandra com \emph{clusters} de um, dois, quatro e seis máquinas, além das descrições das etapas e programas utilizados. O programa é exposto brevemente e o modelo de dados e o ambiente utilizado são descritos.

\section{Estudo de Caso}
O Bolsa Família é um programa federal, instituído em 2003 pelo então presidente Lula, que visa a transferência de renda para famílias em situação de pobreza e extrema pobreza no Brasil~\cite{caixa-bolsafamilia}. Atualmente cerca de 13,9 milhões de famílias são atendidas pelo programa, que recebem em média R\$182, com um custo total de R\$27,4 bilhões em 2016~\cite{gov-bolsafamilia1, gov-bolsafamilia2}.

Os dados do Bolsa Família utilizados para estudo de caso nesse trabalho foram obtidos no \emph{site} do Portal da Transparência~\cite{portaldatransparencia}. Esses dados são disponibilizados em arquivos agrupados mensalmente em formato \emph{.csv}. 

Foram utilizados no total vinte quatro arquivos, equivalentes a vinte e quatro meses do programa, compreendidos entre Julho de 2014 e Junho de 2016. Cada arquivo possui em média 16GiB de tamanho, com 13.968.749 registros.

Cada arquivo apresenta como campos: \textbf{UF, Código SIAFI Município, Nome Município, Código Função, Código Subfunção, Código Programa, Código Ação, NIS Favorecido, Nome Favorecido, Fonte-Finalidade, Valor Parcela e Mês Competência}. Um subconjunto dessas colunas foi escolhido para a realização dos testes, como explicado na próxima sessão.

\section{Modelo de dados Cassandra}
O modelo de dados no Cassandra foi criado utilizando-se um \emph{keyspace} com estratégia de replicação \emph{SimpleStrategy} com fator de replicação de apenas um~\ref{lst:cql_create_keyspace}, pois a tolerância a falhas não é um fator relevante nos testes a serem realizados, devido ao ambiente controlado em que eles são feitos.

\noindent
\begin{minipage}[c]{1\textwidth}
\begin{lstlisting}[caption={Código CQL criação do keyspace},label={lst:cql_create_keyspace},language=SQL]
CREATE KEYSPACE bolsa_familia WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};
\end{lstlisting}
\end{minipage}

Apenas uma família de colunas foi criada, com as colunas \textbf{UF, Código SIAFI Município, Nome Município, NIS Favorecido, Nome Favorecido, Fonte-Finalidade, Valor Parcela, Mês Competência}. Esse subconjunto foi escolhido pois os testes não buscam uma análise real das informações armazenadas, e sim mensurar o desempenho de um banco de dados distribuido com dados públicos.

Ao se definir uma chave primária no Cassandra é possível escolher uma \emph{Partition Key} (chave de partição) e uma \emph{Clustering Key} (chave de agrupamento). A \emph{Partition Key} é responsável pela distribuição dos dados nos nós do ambiente, enquanto a \emph{Partition Key} distribui os dados dentro de cada nó.

Para o modelo testado foi escolhido como \emph{Partition Key} apenas a coluna \textbf{UF}, pois se deseja obter resultados melhores em consultas que agrupam estados, como por exemplo, o a soma do valor dos benefícios em um estado. Além disso, para complementar a chave primária foram escolhidos os campos \textbf{NIS Favorecido, Valor Parcela e Mês Competência}, que identificam unicamente cada registro, considerando que um mesmo favorecido pelo programa(identificado pela coluna NIS Favorecido), pode receber mais de uma parcela em um mesmo mês, e também em meses distintos.

Foi feito também um ordenamento das colunas, definindo Período e NIS Favorecido em ordem crescente e valor em ordem decrescente~\ref{lst:cql_create}. 

\begin{lstlisting}[caption={Código CQL criação da tabela},label={lst:cql_create},language=SQL]
CREATE TABLE bolsa_familia.dados (uf text, periodo timestamp, valor double, nis_favorecido bigint, cod_municipio int, fonte text, nome_favorecido text, nome_municipio text, PRIMARY KEY(uf, periodo, valor, nis_favorecido)) WITH CLUSTERING ORDER BY(periodo ASC, valor DESC, nis_favorecido ASC);
\end{lstlisting}

A configuração do ambiente Cassandra foi feita por meio do cliente \emph{cqlsh}, que permite realizar consultas e manipulações no banco por meio da linguagem \emph{CQL}(\emph{Cassandra Query Language}).

\section{Desenvolvimento da aplicação}
Para inserção e busca dos dados no ambiente, foi desenvolvida uma aplicação em Java utilizando o \emph{driver} disponibilizado pela \emph{Datastax}. Essa aplicação é responsável pela leitura de todos os arquivos de entrada e a inserção dos campos utilizados no banco de dados Cassandra, assim como a posterior busca dos dados.

A inserção dos dados é feita de forma assíncrona utilizando os métodos do \emph{driver}. A filtragem dos campos utilizados é feita no momento da inserção pelo próprio programa desenvolvido.

A leitura dos dados é feita no mesmo programa, após a inserção de todos os dados, também utilizando o driver da \emph{Datastax}.

Todas as interações com o banco, seja na inserção quanto na leitura, foram realizadas por meio da linguagem CQL, que se assemelha a consultas padrões SQL.

\section{Arquitetura do Ambiente}
O ambiente utilizado consiste em seis máquinas com Intel i5-4570 3.20GHz, 16GB de RAM, disco rígido de 500GB, com sistema operacional Ubuntu.

O cliente Cassandra foi instalado em cada uma das seis máquinas utilizadas no teste. Em cada máquina foi necessário a modificação do arquivo de configuração \emph{cassandra.yaml} para possibilitar a detecção do \emph{cluster}.

Além disso, seguindo as orientações em ~\cite{cassandrasettings}, e guardadas as devidas limitações do laboratório, foram realizadas as seguintes configurações do Linux:
\begin{itemize}
	\item Remoção do limite de memória(\emph{memlock})
	\item Aumento do limite do número de arquivos abertos(\emph{nofile})
	\item Desativação do \emph{swap}
\end{itemize}




